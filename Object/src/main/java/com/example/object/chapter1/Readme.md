# Chapter 1 - 객체, 설계
***

### 이론이 먼저일까, 실무가 먼저일까?
대부분의 사람들은 이론이 먼저 정립된 후에 실무가 그 뒤를 따라 발전한다고 생각한다. 하지만 글래스(Robert L. Glass)에 따르면 어떤 분야를 막론하고 이론을 정립할 수 없는 초기에는 실무가 먼저 급속한 발전을 이룬다고 한다.  
실무가 어느 정도 발전하고 난 다음에야, 비로소 실무의 실용성을 입증할 수 있는 이론이 서서히 그 모습을 갖춰가기 시작하고, 해당 분야가 충분히 성숙해지는 시점에 이르러서야 이론이 실무를 추월하게 된다는 것이다.  
    
    한마디로 요악하면, 이론보다 실무가 먼저라는 것이다.

건축처럼 역사가 오래된 여느 다른 공학분야에 비해 상대적으로 짧은 소프트웨어 분야의 역사를 감안했을 때 글래스가 우리에게 전하고자 하는 메세지는 분명하다.
소프트웨어 분야는 아직 걸음마 단계에 머물러 있기 때문에 이론보다 실무가 더 앞서 있으며 실무가 더 중요하다는 것이다.  

이런 이야기에서 알 수 있듯이, 여기서는 객체지향 패러다임을 설명하기 위해 추상적인 개념이나 이론을 앞세우지 않고 코드를 이용해 객체지향의 다양한 측면을 설명하려고 노력 할 것이다.

## 티켓 판매 애플리케이션 구현하기
***
    연극이나 음악회를 공연할 수 있는 작은 소극장을 경영하고 있다고 상상해보자.
    소극장의 홍보를 위해 작은 이벤트를 기획하였는데, 내용은 추첨을 통해 선정된
    관객들에게 무료로 관람할 수 있는 초대장을 발송하는 것이다.
    이벤트는 성황리에 마감됐고, 공연 날이 밝았다.
    하지만 한 가지 염두해야 할 점은 이벤트에 당첨된 관람객과 그렇지 못한 관람객은
    다른 방식으로 입장시켜야 한다는 것이다.

- 이벤트 당첨자에게 발송되는 초대장 구현하기
- 공연을 관람하기 원하는 모든 사람들은 티켓을 소지하고 있어야 한다
- 소지품을 보관할 용도의 가방 클래스를 구현하자. 단 초대장, 현금, 티켓만 변수로 포함한다
- 관람객 클래스 구현, 관람객은 소지품을 보관하기 위해 가방을 소지할 수 있음
- 매표소 클래스 구현
- 판매원 클래스 구현
- 위의 결과물을 바탕으로, 소극장 클래스 구현

# Chapter 1.2 - 무엇이 문제인가
***
앞서 작성한 프로그램의 로직은 간단하고 예상대로 동작한다. 하지만, 몇 가지의 문제점을 가지고 있다.  

[**클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천방법**]에는 소프트웨어 모듈이 가져야 하는 세 가지 기능에 관해 설명한다.  
여기서 모듈이란, 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소를 의미한다.

    모든 소프트웨어 모듈에는 세 가지 목적이 있다.
    첫 번째 목적은 실행 중에 제대로 동작하는 것이다 - 모듈의 존재 이유이다.
    두 번째 목적은 변경을 위해 존재하는 것이다 - 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.
    세 번째 목적은 코드를 읽는 사람과 의사소통 해야 하는 것이다 - 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.

앞서 만든 프로그램은 관람객들을 입장시키는 데 필요한 기능을 오류 없이 수행하고 있지만, 변경 용이성과 의사소통 면에서의 목적은 만족시키지 못 하고 있다.  

### 예상을 빗나가는 코드  
마지막에 구현한 Theater 클래스의 enter 메서드가 수행하는 일을 말로 풀어보자.  

    소극장은 관람객의 가방을 열어 그 안에 초대장이 들어 있는지 살펴본다. 가방 안에 초대장이 들어 있으면 
    판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다. 가방 안에 초대장이 들어 있지 않다면
    관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한 후에 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.

#### 관람객과 판매원의 소극장의 통제를 받는 수동적인 존재라는 점이 큰 문제이다.

관람객의 입장에서, 소극장이라는 제 3자가 초대장을 확인하기 위해 관람객의 가방을 마음대로 열어보는 것이 불만이다.  
판매원에 입장에서, 소극장이 허락도 없이 매표소에 보관중인 티켓과 현금에 마음대로 접근할 수 있고 관람객에게서 받은 돈을 판매원이 아닌 소극장이 수행한다.  

또한, 코드를 이해하기 어렵게 작성되어 있다.  
Theater의 Enter 메소드를 이해하기 위해서는 Audience가 Bag을 가지고 있고, Bag 안에는 현금과 티켓이 들어있으며  
TicketSeller가 TicketOffice에서 티켓을 판매하고, TicketOffice안에 돈과 티켓이 보관되어 있다는 사실을 알아야 한다.

### 변경에 취약한 코드
#### 더 큰 문제는, 변경에 취약하다는 것이다.  

관람객이 가방을 들고다니지 않는다면? 관람객이 현금이 아니라 카드를 이용해 계산한다면? 매표소 밖에서 티켓을 판매해야 한다면? ...  
관람객이 가방을 들고 있다는 가정 한 가지만 바뀐다 하더라도, 우리는 Audience 클래스에서 Bag을 제거해야 하고, Theater의 enter 메소드도 수정해야 한다.  
이러한 세부적인 사실 하나만 바뀌어도 해당 클래스뿐만 아니라 이 클래스에 의존하는 클래스들도 같이 변경해야 하는 것이다.  

이것은 객체 사이의 **의존성(Dependency)** 과 관련된 문제다. 문제는 의존성이 변경과 관련돼 있다는 점이다. 의존성은 변경에 대한 영향을 암시한다.  
의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.  
    
    그렇다고 해서 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다. 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다.
    따라서 우리의 목표는 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다

객체 사이의 의존성이 과한 경우를 가리켜 **결합도(coupling)**가 높다고 말한다. 결합도는 의존성과 관련돼 있기 때문에 결합도 역시 변경과 관련이 있다.  
두 객체 사이의 결합도가 높으면 높을수록 함께 변경될 확률도 높아지기 때문에 변경하기 어려워진다.  
따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이어야 한다.

# Chapter1.3 - 설계 개선하기
***
